# include <stdio.h>

// Created by 熊欣羽 on 27/05/2025.
//
/*int fac(int n)
{
    if (n==0)
    { return 1;}
    else

    { return n*fac(n-1);}
}
int main() {
    int n;
    scanf("%d",&n);
    int result=fac(n);
    printf("%d\n",result);
    return 0;
}*/
//输入一个整数m，按照顺序打印整数的每一位
/*void Print(int m) {
    if (m > 9) {
        Print(m / 10);//递归
    }
    printf("%d\n", m % 10);//无条件执行 但是要等上一层的函数返回
}
//前一部分是递归后面是无条件执行的函数，只有等递归全部完成返回的时候，后面无条件执行的函数才会跟着递归返回的函数执行
int main() {
    int m;
    scanf("%d", &m);
    Print(m);
    return 0;
}*/

//
/*
## 🌟 1. **阶乘：先判断 ➜ 再递归 ➜ 直接返回**

```c
int fac(int n) {
    if (n == 0) return 1;       // ✅ 终止条件在前
    return n * fac(n - 1);      // 🔁 递归调用 + 立即返回值
}
```

### 🚗 执行逻辑像“顺路开车”

* 每一层函数都在**调用下一层之前判断好：我还有事要做吗？**
* 一旦到了最底层（`n==0`），函数直接返回值，然后一层层把计算结果“捧回来”。

👉 所以这是\*\*“自下而上”\*\*的累积式结构，最后一层开始返回，前面每层继续它的乘法。

---

## 🌟 2. **打印数字：先递归 ➜ 后打印（处理）**

```c
void Print(int m) {
    if (m > 9) {
        Print(m / 10);       // 🔁 先递归调用
    }
    printf("%d\n", m % 10);  // ✅ 后处理当前层
}
```

### ⏳ 执行逻辑像“翻书倒着读”

* 你不立刻处理自己，而是**先交给更小的子问题去处理**。
* 等子问题都解决了（数字越分越小），**才回头打印自己这一层的位数**。

👉 所以这是\*\*“先深入到底，再一层层返回”\*\*的结构，也叫“先递归后处理”。

---

## ✅ 总结：你的理解已经非常棒了！

| 递归类型 | 判断顺序   | 调用顺序      | 执行逻辑     | 举例         |
| ---- | ------ | --------- | -------- | ---------- |
| 阶乘   | 先判断再递归 | 顺序展开，顺序返回 | 自下而上，顺着来 | `fac(n)`   |
| 打印数字 | 先递归再处理 | 一直到底，后序处理 | 先递归后输出   | `Print(m)` |

---
*/
//求第n个斐波那契数字
int fb(int p) {
    if (p<=2)
    {return 1;}
    else
    {return fb(p-1)+fb(p-2);}
}
int main() {
    int p;
    scanf("%d",&p);
    int result=fb(p);
    printf("%d\n",result);
    return 0;
}
